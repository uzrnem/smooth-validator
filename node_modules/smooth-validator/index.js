const dataType = require('./dataType');
const stringFuncs = require('./validator/string');
const generalFuncs = require('./validator/general');
const numericFuncs = require('./validator/numeric');
const dateFuncs = require('./validator/date');
const booleanFuncs = require('./validator/boolean');
const paramFuncs = require('./helper/params');
const messageFuncs = require('./helper/message')

function parseCondition(conditionStr) {
  var details = conditionStr.split(":");
  switch (details[0]) {
    //General
    case 'required': return paramFuncs.noExtraParams(conditionStr);
    case 'required_if': return paramFuncs.twoExtraParams(conditionStr);
    case 'same': return paramFuncs.oneExtraParams(conditionStr);
    //Boolean
    case 'boolean': return paramFuncs.noExtraParams(conditionStr);
    //Integer
    case 'numeric': return paramFuncs.noExtraParams(conditionStr);
    case 'between': return paramFuncs.twoExtraParams(conditionStr);
    case 'gt':
    case 'gte':
    case 'lt':
    case 'lte': return paramFuncs.oneExtraParams(conditionStr);
    case 'odd':
    case 'even': return paramFuncs.noExtraParams(conditionStr);
    //String
    case 'alpha':
    case 'alphanumeric':
    case 'uppercase':
    case 'lowercase': return paramFuncs.anyExtraParams(conditionStr);
    case 'min':
    case 'max':
    case 'size': return paramFuncs.oneExtraParams(conditionStr);
    case 'starts_with':
    case 'starts_not_with':
    case 'ends_with':
    case 'ends_not_with':
    case 'contains':
    case 'contains_any':
    case 'in':
    case 'not_in': return paramFuncs.manyExtraParams(conditionStr);
    //Email
    case 'email': return paramFuncs.noExtraParams(conditionStr);
    //Date
    case 'date': return paramFuncs.noExtraParams(conditionStr);
    case 'after':
    case 'after_or_equals':
    case 'before':
    case 'before_or_equals': return paramFuncs.oneExtraParams(conditionStr);
    default: throw "Invalid validation " + conditionStr + ", not allowed"
  }
}

function checkVariableErrors(varName, condKey, varValue, condValues, dataObj) {
  switch (condKey) {
    //General
    case 'required': return generalFuncs.validateRequired(varName, varValue)
    case 'required_if': return generalFuncs.validateRequiredIf(varName, varValue, condValues, dataObj)
    case 'same': return generalFuncs.validateSame(varName, varValue, condValues, dataObj)
    //Boolean
    case 'boolean': return booleanFuncs.validateBoolean(varName, varValue)
    //Integer
    case 'numeric': return numericFuncs.validateNumeric(varName, varValue)
    case 'between': return numericFuncs.validateBetween(varName, varValue, condValues, dataObj)
    case 'gt': return numericFuncs.validateGt(varName, varValue, condValues, dataObj)
    case 'gte': return numericFuncs.validateGte(varName, varValue, condValues, dataObj)
    case 'lt': return numericFuncs.validateLt(varName, varValue, condValues, dataObj)
    case 'lte': return numericFuncs.validateLte(varName, varValue, condValues, dataObj)
    case 'odd': return numericFuncs.validateOdd(varName, varValue)
    case 'even': return numericFuncs.validateEven(varName, varValue)
    //String
    case 'alpha': return stringFuncs.validateRegex('alpha', varName, varValue, condValues)
    case 'alphanumeric': return stringFuncs.validateRegex('alphanumeric', varName, varValue, condValues)
    case 'uppercase': return stringFuncs.validateCase('uppercase', varName, varValue, condValues)
    case 'lowercase': return stringFuncs.validateCase('lowercase', varName, varValue, condValues)
    case 'min': return stringFuncs.validateMin(varName, varValue, condValues)
    case 'max': return stringFuncs.validateMax(varName, varValue, condValues)
    case 'size': return stringFuncs.validateSize(varName, varValue, condValues)
    case 'starts_with': return stringFuncs.validateStartsWith(varName, varValue, condValues)
    case 'starts_not_with': return stringFuncs.validateStartsNotWith(varName, varValue, condValues)
    case 'ends_with': return stringFuncs.validateEndsWith(varName, varValue, condValues)
    case 'ends_not_with': return stringFuncs.validateEndsNotWith(varName, varValue, condValues)
    case 'contains': return stringFuncs.validateContains(varName, varValue, condValues)
    case 'contains_any': return stringFuncs.validateContainsAny(varName, varValue, condValues)
    case 'in': return stringFuncs.validateIn(varName, varValue, condValues)
    case 'not_in': return stringFuncs.validateNotIn(varName, varValue, condValues)
    //Email
    case 'email': return stringFuncs.validateEmail(varName, varValue)
    //Date
    case 'date': return dateFuncs.validateDate(varName, varValue)
    case 'after': return dateFuncs.validateDateComparison('after', varName, varValue, condValues, dataObj)
    case 'after_or_equals': return dateFuncs.validateDateComparison('after_or_equals', varName, varValue, condValues, dataObj)
    case 'before': return dateFuncs.validateDateComparison('before', varName, varValue, condValues, dataObj)
    case 'before_or_equals': return dateFuncs.validateDateComparison('before_or_equals', varName, varValue, condValues, dataObj)
    default: return { resKey: varName, resMsg: ' is invalid validator on ' + varName };
  }
}

function stringParse(rawConditions) {
  var parsedConditions = [];
  var condArr = rawConditions.split("|");
  for (var c = 0; c < condArr.length; c++) {
    parsedConditions.push(parseCondition(condArr[c]));
  }
  return parsedConditions;
}

function objectParse(rawConditions) {
  var parsedRules = {};
  for (var [variable, rawConditions] of Object.entries(rawConditions)) {
    parsedRules[variable] = parseRules(variable, rawConditions);
  }
  return parsedRules
}

function parseRules(variable, rawConditions) {
  /* Parse something like this {'name' : 'alpha|max:20'} into name:
    * [{ keys: 'alpha', value: null },
    *  { keys: 'max', value: [Array] } ],
    */
  if (dataType.isString(rawConditions)) {
    return stringParse(rawConditions);
  } else if (dataType.isArray(rawConditions)) {
    if (dataType.isString(rawConditions[0])) {
      return {type: 'array', __rules: stringParse(rawConditions[0])}
    } else {
      return {type: 'array', __rules: objectParse(rawConditions[0])}
    }
  } else {
    return {type: 'object', __rules: objectParse(rawConditions)}
  }
}

function validateArray(dataObj,variable, conditions, varValue) {
  var errors = [];
  for (let c in conditions) {
    if (
      !dataType.isEmpty(varValue) ||
      conditions[c].key == "required" ||
      conditions[c].key == "required_if"
    ) {
      var err = checkVariableErrors(variable, conditions[c].key, varValue, conditions[c].value, dataObj);
      if (err != null) {
        err.key = conditions[c].key
        err.variable = variable
        errors.push(err)
      }
    }
  }
  return errors
}

function validate(dataObj,parsedRulesObj) {
  var errors = [];
  for (var [variable, conditions] of Object.entries(parsedRulesObj)) {
    var varName = variable.replace('*', '')
    var varValue = dataObj ? dataObj[varName] : null;
    if (dataType.isArray(conditions)) {
      errors.push(...validateArray(dataObj,varName, conditions, varValue) )
    } else {
      if (variable.startsWith('*') && dataType.isEmpty(varValue)) {
        errors.push({
          variable: varName,
          name: varName,
          value: varValue,
          first_value: varValue,
          key: 'required'
        })
      } else if (conditions.type == 'array') {
        for(c = 0; c < varValue.length; c++) {
          if (dataType.isObject(varValue[c])) {
            errs = validate(varValue[c], conditions.__rules)
            errs.forEach(err => {
              err.variable = varName + '.' + err.variable
              err.index = c
              errors.push(err)
            })
          } else if (dataType.isString(varValue[c])) {
            var data1 = {}
            var rules1 = {}
            varIndex = varName + '[' + c + ']'
            data1[varIndex] = varValue[c]
            rules1[varIndex] = conditions.__rules
            errs = validate(data1, rules1)
            errs.forEach(err => {
              err.index = c
              errors.push(err)
            })
          }
        }
      } else if (conditions.type == 'object') {
        errs = validate(dataObj[varName], conditions.__rules)
        errs.forEach(err => {
          err.variable = varName + '.' + err.variable
          errors.push(err)
        })
      } else {
        console.error('failed', { variable, varValue, dataObj, conditions})
      }
    }
  }
  return errors
}

var parser = function (rawRules, params = { date_format: null, message: {} }) {
  var parsedRulesObj = {};
  for (var [variable, rawConditions] of Object.entries(rawRules)) {
    parsedRulesObj[variable] = parseRules(variable, rawConditions);
  }
  return function (dataObj) {
    var errors = [];
    var errs = validate(dataObj, parsedRulesObj)
    errs.forEach(err => {
      errors.push(messageFuncs(err.key, err, params.message))
    })
    return { message: errors.length > 0 ? errors[0]['message']: 'validation passed', errors: errors };
  };
}
module.exports = parser