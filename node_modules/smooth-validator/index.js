const dataType = require('./dataType');
const stringFuncs = require('./functions/string');
const generalFuncs = require('./functions/general');
const numericFuncs = require('./functions/numeric');
const dateFuncs = require('./functions/date');
const booleanFuncs = require('./functions/boolean');
const paramFuncs = require('./functions/params');

function parseCondition(conditionStr) {
  var details = conditionStr.split(":");
  switch (details[0]) {
    //General
    case 'required': return paramFuncs.noExtraParams(conditionStr);
    case 'same': return paramFuncs.oneExtraParams(conditionStr);
    //Boolean
    case 'boolean': return paramFuncs.noExtraParams(conditionStr);
    //Integer
    case 'numeric': return paramFuncs.noExtraParams(conditionStr);
    case 'between': return paramFuncs.twoExtraParams(conditionStr);
    case 'gt': return paramFuncs.oneExtraParams(conditionStr);
    case 'gte': return paramFuncs.oneExtraParams(conditionStr);
    case 'lt': return paramFuncs.oneExtraParams(conditionStr);
    case 'lte': return paramFuncs.oneExtraParams(conditionStr);
    //String
    case 'alpha': return paramFuncs.anyExtraParams(conditionStr);
    case 'alphanumeric': return paramFuncs.anyExtraParams(conditionStr);
    case 'uppercase': return paramFuncs.anyExtraParams(conditionStr);
    case 'lowercase': return paramFuncs.anyExtraParams(conditionStr);
    case 'min': return paramFuncs.oneExtraParams(conditionStr);
    case 'max': return paramFuncs.oneExtraParams(conditionStr);
    case 'size': return paramFuncs.oneExtraParams(conditionStr);
    case 'starts_with': return paramFuncs.manyExtraParams(conditionStr);
    case 'ends_with': return paramFuncs.manyExtraParams(conditionStr);
    //Array
    case 'in': return paramFuncs.manyExtraParams(conditionStr);
    case 'not_in': return paramFuncs.manyExtraParams(conditionStr);
    //Email
    case 'email': return paramFuncs.noExtraParams(conditionStr);
    //Date
    case 'date': return paramFuncs.noExtraParams(conditionStr);
    case 'after': return paramFuncs.oneExtraParams(conditionStr);
    case 'after_or_equals': return paramFuncs.oneExtraParams(conditionStr);
    case 'before': return paramFuncs.oneExtraParams(conditionStr);
    case 'before_or_equals': return paramFuncs.oneExtraParams(conditionStr);
    default: throw "Invalid validation " + conditionStr + ", not allowed"
  }
}

function checkVariableErrors(varName, condKey, varValue, condValues, dataObj) {
  switch (condKey) {
    //General
    case 'required': return generalFuncs.validateRequired(varName, varValue)
    case 'same': return generalFuncs.validateSame(varName, varValue, condValues, dataObj)
    //Boolean
    case 'boolean': return booleanFuncs.validateBoolean(varName, varValue)
    //Integer
    case 'numeric': return numericFuncs.validateNumeric(varName, varValue)
    case 'between': return numericFuncs.validateBetween(varName, varValue, condValues, dataObj)
    case 'gt': return numericFuncs.validateGt(varName, varValue, condValues, dataObj)
    case 'gte': return numericFuncs.validateGte(varName, varValue, condValues, dataObj)
    case 'lt': return numericFuncs.validateLt(varName, varValue, condValues, dataObj)
    case 'lte': return numericFuncs.validateLte(varName, varValue, condValues, dataObj)
    //String
    case 'alpha': return stringFuncs.validateRegex('alpha', varName, varValue, condValues)
    case 'alphanumeric': return stringFuncs.validateRegex('alphanumeric', varName, varValue, condValues)
    case 'uppercase': return stringFuncs.validateCase('uppercase', varName, varValue, condValues)
    case 'lowercase': return stringFuncs.validateCase('lowercase', varName, varValue, condValues)
    case 'min': return stringFuncs.validateMin(varName, varValue, condValues)
    case 'max': return stringFuncs.validateMax(varName, varValue, condValues)
    case 'size': return stringFuncs.validateSize(varName, varValue, condValues)
    case 'starts_with': return stringFuncs.validateStartsWith(varName, varValue, condValues)
    case 'ends_with': return stringFuncs.validateEndsWith(varName, varValue, condValues)
    //Array
    case 'in': return stringFuncs.validateIn(varName, varValue, condValues)
    case 'not_in': return stringFuncs.validateNotIn(varName, varValue, condValues)
    //Email
    case 'email': return stringFuncs.validateEmail(varName, varValue)
    //Date
    case 'date': return dateFuncs.validateDate(varName, varValue)
    case 'after': return dateFuncs.validateDateComparison('after', varName, varValue, condValues, dataObj)
    case 'after_or_equals': return dateFuncs.validateDateComparison('after_or_equals', varName, varValue, condValues, dataObj)
    case 'before': return dateFuncs.validateDateComparison('before', varName, varValue, condValues, dataObj)
    case 'before_or_equals': return dateFuncs.validateDateComparison('before_or_equals', varName, varValue, condValues, dataObj)
    default: return { resKey: varName, resMsg: ' is invalid validator on ' + varName };
  }
  return { resKey: false, resMsg: null };
}

var parser = function (rawRules) {
  var parsedRules = {};
  for (var [variable, rawConditions] of Object.entries(rawRules)) {
    var parsedConditions = [];
    /* Parse something like this {'name' : 'alpha|max:20'} into name:
     * [{ keys: 'alpha', value: null },
     *  { keys: 'max', value: [Array] } ],
     */
    var condArr = rawConditions.split("|");
    for (var c = 0; c < condArr.length; c++) {
      parsedConditions.push(parseCondition(condArr[c]));
    }
    parsedRules[variable] = parsedConditions;
  }
  return function (dataObj) {
    var errors = [];
    for (var [variable, conditions] of Object.entries(parsedRules)) {
      var varValue = dataObj[variable];
      for (let c in conditions) {
        if (!dataType.isEmpty(varValue) || conditions[c].key == "required") {
          var {resKey, resMsg} = checkVariableErrors(variable, conditions[c].key, varValue, conditions[c].value, dataObj);
          if (resKey && resMsg) {
            errors.push({ key: resKey, message: resKey + resMsg })
          }
        }
      }
    }
    return { message: errors.length > 0 ? errors[0]['message']: 'validation passed', errors: errors };
  };
}
module.exports = parser