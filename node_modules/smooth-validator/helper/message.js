const dataType = require('../dataType');
const helper = require('../helper');

function getErrorMessageBy(key) {
  switch ( key ) {
    //General
    case 'required': return ':variable is required';
    case 'required_if': return ':variable is required';
    case 'same': return ':variable is not equal to :first_value';
    //Boolean
    case 'boolean': return ':variable is not boolean';
    //Integer
    case 'numeric': return ':variable is not number';
    case 'between': return ':variable should be greater than :first_value and less than :second_value';
    case 'gt': return ':variable should be greater than :first_value';
    case 'gte': return ':variable should be greater than or equals to :first_value';
    case 'lt': return ':variable should be less than :first_value';
    case 'lte': return ':variable should be less than or equals to :first_value';
    case 'odd': return ':variable is not odd number';
    case 'even': return ':variable is not even number';
    //String
    case 'alpha': return ':variable does not match alpha';
    case 'alphanumeric': return ':variable does not match alphanumeric';
    case 'uppercase': return ':variable does not match uppercase';
    case 'lowercase': return ':variable does not match lowercase';
    case 'min': return ':variable\'s length is less than :first_value';
    case 'max': return ':variable\'s length is greater than :first_value';
    case 'size': return ':variable\'s length not equal to :first_value';
    case 'starts_with': return ':variable does not starts with :first_value';
    case 'starts_not_with': return ':variable does starts with :first_value';
    case 'ends_with': return ':variable does not ends with :first_value';
    case 'ends_not_with': return ':variable does ends with \':first_value\'';
    case 'contains': return ':variable does not contains \':first_value\'';
    case 'contains_any': return ':variable does not contains any of :first_value';
    case 'in': return ':variable\'s value is not in array';
    case 'not_in': return ':variable\'s value is in invalid array';
    //Email
    case 'email': return ':variable is invalid';
    //Date
    case 'date': return ':variable is not in date format';
    case 'after': return ':variable is not after :first_value';
    case 'after_or_equals': return ':variable is not after or equals to :first_value';
    case 'before': return ':variable is not before :first_value';
    case 'before_or_equals': return ':variable is not before or equals to :first_value';
    default: return ':variable is invalid'
  }
}
var message = function (key, error, params = {}) {
  var object = {}
  if (error && error.variable && error.variable.indexOf("[") > 0) {
    [error.variable, object] = helper.getUnindexKeyAndObject(error.variable)
  }
  var isMessagePresent = !dataType.isEmpty(params[error.variable + '.' + key])
  var message = (
      isMessagePresent ?
        params[error.variable + '.' + key] :
        getErrorMessageBy(key)
    )
    .replace(":name", error.name)
    .replace(":variable", error.variable.replace(/[0-9\[\]]/g, ''))
    .replace(":value", error.value)
    .replace(":first_value", error.first_value)
    .replace(":second_value", error.second_value)
    .replace(":index", error.index)
    .replace(":type", error.key)

  for (var [index, value] of Object.entries(object)) {
    message = message.replace(':' + index , value)
  }

  return {
    key: error.variable, message
  };
}
module.exports = message